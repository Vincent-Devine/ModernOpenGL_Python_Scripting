# Scripting system

**Authors : Vincent Devine, Lise Omaya**

For ISART Digital

<hr /><br />

## **Project description :**
We aimed to call python scripts into the engine we previously developed using C++. 
We used the version of our engine which allow multithreading.
To integrate Python we were given the option to choose between Swig and Pybing. We chose the latter.
We managed to use Python for our gameplay loop (our player and camera update) and scene initialization. We also coded the HotReload.
<hr /><br />

## **Step 0 : Pybind11 & Swig**
*Pybind11 is a "lightweight header-only library" which means the compiler can see all its functions, macros and classes directly in the header. This library allows to create bindings of existing C++ code. To put it simply, it helps to create an interface which call C++ code.*

*Swig is an "interface compiler" which means it has its own C++ parser instead of a C++ template like Pybind11. It can be used to "translate" C++ into a lot of langages such as Python, Lua or PHP or Java.*

**Installation :**
```diff
+ Pybind is easier to install 
    There is no need to compile a lightweight header-only library.
    We only needed to download  the library and include it.
- Swig required more time to work
    We had to modify the project setting and move and/or rename files even for basic testing.
```
**Documentation & active community :**
```diff
+ Pybind has good documentation and active community
    It is easy to find video tutorials and a lot of bugs are resolved online.
- Swig documentation is fine but there is a lack of users
    It is hard to find visual aid online and the documentation is extensive but old.
```
**Optimization :**
```diff
+ Pybind11 is more optimized 
    It is not particularly visible for a project of this size but we only needed to create Python bindings into C++.
- Swig is heavier to compile
    Its many translating possibilities are not worth it for us.
```
**Module writing time :**
```diff
+ Swig module generates automatically which is far quicker 
    We only need to tell Swig which header we wish to wrap.
- Pybind11 module can be long to write 
    Each classes variable and method must be given by hand which is very tedious for "huge" classes.
```
**Customization :**
```diff
+ Pybind11 gives more control
  As the developer needs to write the module himself, it is possible to choose exactly what we send to Python (no useless variables, ...).
- Swig can be configured but by default, it generates automatically a module
    Since the module is generated by swig itself it is harder to control what is sent.
    A solution would be to send function by function but it would be the same as using Pybind11 but less optimized.
```
**Versatility :**  
```diff
+ Swig is far more versatile
    It can translate C and C++ into many languages.
- Pybind11 is limited 
    You can only translate to C++ into Python.
```
## **Step 2 : Build interface**
We put the Python and pybind libraries into our project and included it in our files.<br /><br />
*Build an interface in Python:*<br />
- We first created a header Binding.h where we put all the functions and classes we would later give to Python script.
```c++
PYBIND11_EMBEDDED_MODULE(embeddedmodule, module)
{
	module.doc() = "Embedded Module";
	module.def("AddGameObjectInCurrentScene", &AddGameObjectInCurrentScene);
	module.def("CreateCollider", &CreateCollider);
	module.def("SetLastColliderToLastGameObject", &SetLastColliderToLastGameObject);
.....


	pybind11::class_<Core::Maths::Vec3>(module, "Vec3")
		.def(pybind11::init<const float&, const float&, const float&>(), "Constructor", pybind11::arg("p_x"), pybind11::arg("p_y"), pybind11::arg("p_z"))
		.def(pybind11::init<const Core::Maths::Vec3&>(), "ConstructorCopy", pybind11::arg("p_vec3"))
		.def_readwrite("x", &Core::Maths::Vec3::x)
		.def_readwrite("y", &Core::Maths::Vec3::y)
		.def_readwrite("z", &Core::Maths::Vec3::z)
		.def("Normalize", &Core::Maths::Vec3::Normalize)
		.def("CrossProduct", &Core::Maths::Vec3::CrossProduct)
		.def(pybind11::self + pybind11::self)
		.def(pybind11::self - pybind11::self)
		.def(-pybind11::self)
		.def(pybind11::self += pybind11::self)
		;

......

}
```
*Example : Binding.h*

- Than we took our code in C++ (for the player controls, camera and initialization) and translated it into Python script (PlayerMove.py, PlayerJump.py, DeathZone.py and SceneInit.py).
```python
import embeddedmodule
import math

def PlayerMove(inputs : embeddedmodule.Inputs, rb : embeddedmodule.Rigidbody, transform : embeddedmodule.Transform, forwardCam : embeddedmodule.Vec3, rightCam : embeddedmodule.Vec3) -> None :
	move : embeddedmodule.Vec3 = embeddedmodule.Vec3(0, rb.velocity.y, 0)

	speed : float = 15
	YRotation: float
	if (forwardCam.x > 0 and forwardCam.z >= 0)  :
		YRotation = math.atan(forwardCam.z / forwardCam.x)
	elif (forwardCam.x > 0 and forwardCam.z < 0):
		YRotation = math.atan(forwardCam.z / forwardCam.x) + 2 * math.pi
	elif (forwardCam.x < 0) :
		YRotation = math.atan(forwardCam.z / forwardCam.x) + math.pi
	elif (forwardCam.x == 0 and forwardCam.z > 0) :
		YRotation = math.pi/2
	else :
		YRotation = -math.pi/2

....	
```
*Example : PlayerMove.py*

- We also created a vector of scripts that we put in our App to initialize and manage them (to prevent it from reading our python files infinitely).
```c++
void App::ImportScript()
{
    scripts.push_back(pybind11::module::import("InitScene"));
    scripts.push_back(pybind11::module::import("PlayerMove"));
    scripts.push_back(pybind11::module::import("PlayerJump"));
    scripts.push_back(pybind11::module::import("Camera"));
}
```
*Example : App.cpp*
- Finally, we called our python scripts in our GameObject to allow it to call them for the player and the camera. <br />

## **Step 3 : Hot Reload**
- Since we stocked our scripts in a vector we were able to go through their reload function to allow them to be reloaded and modified during run-time.
```c++
void App::ReloadScript(Core::Inputs p_inputs)
{
    if (p_inputs.reloadScript)
    {
        for (pybind11::module script : scripts)
            script.reload();
    }
}
```
*Example : App.cpp*
## **Step 4 : Empty main**
- We managed to initialize all our resources (meshes, gameObjects ...) with python script.
```python
import embeddedmodule

def InitGameObject() -> None :
    #PotatOs
    embeddedmodule.AddGameObjectInCurrentScene(
    "PotatOS", "BasicShader", "PotatOSText", 
    -1, -2, -5, 0.2, 0.2, 0.2, 0, 45, 0,
    "PotatOs", False)

    #Companion
    embeddedmodule.AddGameObjectInCurrentScene(
    "Companion", "BasicShader", "CompanionText", 
    -5, 3, 6, 0.1, 0.1, 0.1, 0, 0, 0,
    "Companion", False)

    #Slime
    embeddedmodule.AddGameObjectInCurrentScene(
    "Slime", "BasicShader", "SlimeText", 
    -23, 4, 11, 1, 1, 1, 0, 25, -22,
    "Slime", False)

    #Chocobo
    embeddedmodule.AddGameObjectInCurrentScene(
    "Chocobo", "BasicShader", "ChocoboText", 
    6, -4, 4, 0.02, 0.02, 0.02, 0, 150, -180,
    "Chocobo", False)
....
```
- The difficulty was managing a lot of resources that need a lot of parameters.
- We divided our code into several functions to limit their number.

```c++
void AddGameObjectInCurrentScene(const std::string& p_mesh, const std::string& p_shader, const std::string& p_texture, 
	const float p_positionX, const float p_positionY, const float p_positionZ, 
	const float p_scaleX, const float p_scaleY, const float p_scaleZ, 
	const float p_rotationX, const float p_rotationY, const float p_rotationZ, 
	const std::string& p_name, const bool p_isPlayer)
{
	Core::App* app = Core::App::GetInstance();

	LowRenderer::Model model = app->CreateModel(p_mesh, p_shader, p_texture);

	LowRenderer::GameObject* gameObject = new LowRenderer::GameObject(model, Physics::Transform(
		Core::Maths::Vec3(p_positionX, p_positionY, p_positionZ),
		Core::Maths::Vec3(p_scaleX, p_scaleY, p_scaleZ),
		Core::Maths::Vec3(p_rotationX, p_rotationY, p_rotationZ)), p_name);

		app->AddGameObject(gameObject);

}
```
*Example : Binding.h* 

-There is still a lot of parameters, we latter defined class such as Vec3 which shortened our parameter lists.
<hr />

## **Potential features to add:**
- Make our python scripts a resource of our ResourceManager instead of just stocking it in App.

## **To build and run the project :** 
Open the project in Visual Studio and start this (F5).
<br /><hr />
<!-- ![PNG](./OpenGL/Screenshots/Duel.PNG) -->

## **Commands :**
- W/S : Move forward/backward
- A/D : Move left/right
- Space : Jump
- Mouse : Look in a direction 
- Right click : Lock mouse in window
- ESC : Return to menu
- F1 : Show editor/collider
<br /><hr />

<!-- ![PNG](./OpenGL/Screenshots/Setting.PNG) -->
<br /><hr />

<br /><hr />
Code editor : Visual Studio Community <br />
System : Windows